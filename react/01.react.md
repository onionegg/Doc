# react
## 00.開始使用`React`
```html
<script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
```
## 01.建立第一個組件`Component`
```javascript
class MyHead extends React.Component{
    render(){
        return React.createElement('h1',null,'Heloo Component')
    }
}
//1.建立自訂的React組件實體
var myComponent=React.createElement(MyHead,null);
//2.將建立好的React組件實體化到容器中
ReactDOM.render(myComponent,
document.getElementById('demo'))
```
## 02.組件的屬性`Props`
> 讓組件有自己的屬性，可以更靈活的使用組件
```javascript
class MyHead extends React.Component{
    render(){
        //獲取從自訂的React組件實體中的屬性
        console.log(this.props.level)
        return React.createElement('h'+this.props.level,null,'My Componet')
    }
}
//建立自訂的React組件實體，可給定屬性
// React.createElement(
//     組件類別名稱,[屬性物件]
// )
//1.建立自訂的React組件實體，給定屬性
var myComponent=React.createElement(MyHead,{level:3});
ReactDOM.render(myComponent,document.getElementById('demo'))
```
## 03.巢狀組件結構`Components Array`
> 使用迴圈方法建立`巢狀組件結構`
```javascript
class MyHead extends React.Component{
    render(){
        return React.createElement('h'+this.props.level,null,'Components')
    }
}
//[子元件]可以是其他的組件實體
// React.createElement(
//     組件類別名稱,[屬性物件],[子元件]
// )
class MyHeadList extends React.Component{
    render(){
        let heads=[];
        let head;
        for(let i=1;i<6;i++){
            head=React.createElement(MyHead,{level:i});
            heads.push(head)
        }
        return React.createElement('div',null,heads);
    }
}

var myComponent=React.createElement(MyHeadList,null)
ReactDOM.render(myComponent,demo)
```
## 04.組件狀態設置&使用`Component State`
```javascript
// 組件狀態:預期未來會變動的設定
// 組件類別的建構式
// class 組件類別名稱 extends React.Component{
//     constructor(props){
//         一定要先呼叫父類別的建構式
//         super(props)
//        1.this.state={};初始化狀態為空白物件
//        2.this.state={data:10};初始化狀態物件
//     }
// }
// 更新狀態
// setState(新的組件狀態)
// class 組件類別名稱 extends React.Component{
//     update()是我們隨興命名的測試方法
//     update(){
//         使用setState(狀態物件)來更新狀態
//         this.setState({data:'新的資料'})
//          this.setState((currentState,currentProps)=>{
//            {data:currentState.data+1}
//          })
//         禁用直接更新狀態物件
//         (X)this.state={data:"新的資料"}
//     }
// }
// 更新狀態，與目前的狀態有關聯
// setState((目前狀態,目前屬性)=>(新的狀態))
// 更新狀態會自動呼叫 render() 重繪畫面

class MyHead extends React.Component{
    render(){
        return React.createElement('h'+this.props.level,null,'Components')
    }
}
class MyHeadList extends React.Component{
    constructor(props){
        super(props);
        this.state={maxLevel:3};
        window.setTimeout(()=>{
            //this.setState({maxLevel:6});
            this.setState((currentState,currentProps)=>({
                maxLevel:currentState.maxLevel+1
            }))
        },2000)
    }
    render(){
        let heads=[];
        let head;
        for(let i=1;i<this.state.maxLevel;i++){
            head=React.createElement(MyHead,{level:i});
            heads.push(head)
        }
        return React.createElement('div',null,heads);
    }
}

var myComponent=React.createElement(MyHeadList,null)
ReactDOM.render(myComponent,demo)
```
## 05.組件生命週期`Component Circle`
```javascript
// 建立組件:依照順序執行以下方法
// 1.contructor();
// 2.componentWillMount()
// 3.render()
// 4.componentDidMount()
// 更新組件:依照順序執行以下方法
// 1.componentWillUpdate()
// 2.render()
// 3.componentDidUpdate()
// 刪除組件:依照順序執行以下方法
// 1.componentWillUnmount()
//這些方法都是定義在組件的父類別中
//在組件類別中複寫這些方法,就可以在這些方法中加入自訂邏輯
var demo=document.getElementById('demo')
class MyHead extends React.Component{
    render(){
        return React.createElement('h'+this.props.level,null,'Components')
    }
}
class MyHeadList extends React.Component{
    constructor(props){
        super(props);
        this.state={maxLevel:props.start};
    }
    componentWillMount(){//組件將要繪製前時刻
        this.intervalId=window.setInterval(()=>{
            this.setState((currentState,currentProps)=>{
                if(currentState.maxLevel > currentProps.end){
                    return currentState;
                }else{
                    return { maxLevel:currentState.maxLevel+1 }
                }
            })
        },1000)
    }
    componentWillUnmount(){//組件將要刪除前的時候
        window.clearInterval(this.intervalId)
    }
    render(){
        let heads=[];
        let head;
        for(let i=1;i<this.state.maxLevel;i++){
            head=React.createElement(MyHead,{level:i});
            heads.push(head)
        }
        return React.createElement('div',null,heads);
    }
}

var myComponent=React.createElement(MyHeadList,{start:3,end:5})
ReactDOM.render(myComponent,demo)
```